<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Sudoku</title>
    <meta name="theme-color" content="#2196F3">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="My Sudoku">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #ffffff;
            user-select: none;
            overflow: hidden;
            touch-action: manipulation;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            height: 100vh;
            position: fixed;
            width: 100%;
        }

        .app-container {
            max-width: 480px;
            margin: 0 auto;
            background: #1e1e1e;
            min-height: 100vh;
        }

        .app-bar {
            background: #2d2d2d;
            padding: 8px 16px 12px;
            border-bottom: 1px solid #404040;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .app-bar-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .app-bar-bottom-row {
            display: flex;
            justify-content: flex-start; 
            align-items: center;
            gap: 16px;
            width: 100%;
        }

        .back-button {
            background: none;
            border: none;
            color: #ffffff;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            margin-right: 8px;
            opacity: 0.8;
            flex-shrink: 0;
        }

        .back-button:hover {
            opacity: 1;
        }

        .game-info {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
        }

        .game-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
        }

        .app-title {
            font-size: 16px;
            font-weight: bold;
            color: #ffffff;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .timer-display {
            background: #1a237e;
            border: 1px solid #3f51b5;
            border-radius: 4px;
            padding: 2px 4px;
            display: flex;
            align-items: center;
            gap: 2px;
            font-size: 11px;
            font-weight: bold;
            color: #90caf9;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .error-display {
            font-weight: bold;
            font-size: 12px;
            color: #ffffff;
            white-space: nowrap;
            flex-shrink: 0;
            margin-right: 8px; 
        }

        .menu-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 80vh;
            padding: 20px;
        }

        .main-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .subtitle {
            font-size: 18px;
            color: #b0b0b0;
            margin-bottom: 10px;
        }

        .warning-text {
            font-size: 12px;
            color: #4caf50;
            font-style: italic;
            margin-bottom: 30px;
        }

        .option-button, .difficulty-button {
            width: 200px;
            height: 60px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .option-button {
            background: #404040;
            color: #ffffff;
            height: 50px;
        }

        .option-button:hover {
            background: #505050;
        }

        .game-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: calc(100vh - 80px);
            gap: 12px;
        }

        .game-screen.with-coordinates {
            padding-top: 50px;
        }

        .sudoku-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .sudoku-grid-wrapper {
            position: relative;
            display: inline-block;
        }

        .coordinates-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .row-coordinates {
            position: absolute;
            left: -25px;
            top: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            width: 20px;
        }

        .col-coordinates {
            position: absolute;
            top: -25px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 20px;
        }

        .coordinate-label {
            font-size: 12px;
            font-weight: bold;
            color: #90caf9;
            background: #1a237e;
            border: 1px solid #3f51b5;
            border-radius: 3px;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .sudoku-grid {
            width: calc(100vw - 30px);
            max-width: 450px;
            height: calc(100vw - 30px);
            max-height: 450px;
            aspect-ratio: 1;
            border: 3px solid #ffffff;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            margin: 0 auto;
        }

        .sudoku-grid.with-coordinates {
            width: calc(100vw - 80px);
            max-width: 400px;
            height: calc(100vw - 80px);
            max-height: 400px;
        }

        .sudoku-grid.no-events {
            pointer-events: none;
        }

        .sudoku-cell {
            border: 0.5px solid #666666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: 300;
            cursor: pointer;
            position: relative;
            background: #2d2d2d;
            color: #ffffff;
            overflow: hidden;
            transition: background-color 0.3s ease;
        }

        .sudoku-cell.thick-right { border-right: 2px solid #ffffff; }
        .sudoku-cell.thick-bottom { border-bottom: 2px solid #ffffff; }
        .sudoku-cell.selected { 
            background: #ffb74d !important; 
            color: #ffffff;
        }
        .sudoku-cell.error { 
            background: #d32f2f !important; 
            color: #ffffff !important;
        }
        .sudoku-cell.highlight-number { background: #f57c00; }
        .sudoku-cell.highlight-area { background: #424242; }
        .sudoku-cell.original { color: #ffffff; }
        .sudoku-cell.user { color: #90caf9; }
        
        .sudoku-cell span {
            position: relative; 
            z-index: 2; 
        }

        .sudoku-cell.flash-conflict {
            animation: flashRed 0.6s ease-in-out;
        }

        @keyframes flashRed {
            0% { background-color: #2d2d2d; }
            50% { background-color: #f44336; }
            100% { background-color: #2d2d2d; }
        }
        
        .sudoku-cell.initial-fade-in {
            animation: fadeIn 0.5s ease-in forwards;
            opacity: 0; 
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .sudoku-cell.win-animate {
            animation: winSpreadText 0.8s ease-in-out forwards;
        }
        .sudoku-cell.win-animate::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 50%;
            z-index: 20; 
            animation: winSpreadEffect 0.8s ease-in-out forwards;
        }

        @keyframes winSpreadEffect {
            0% { transform: scale(0); background-color: #f57c00; opacity: 1; }
            50% { transform: scale(1.2); background-color: #f57c00; opacity: 1; border-radius: 10%; }
            100% { transform: scale(1); background-color: #424242; opacity: 1; border-radius: 0; }
        }

        @keyframes winSpreadText {
            0%, 49% { 
            }
            50%, 100% { color: #ffffff; }
        }

        .sudoku-cell::after {
            content: '';
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            background-color: #f57c00; 
            transform: scale(0);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 1; 
        }

        .sudoku-cell.animate-complete::after {
            animation: growAndShrink 0.8s ease-in-out;
        }

        @keyframes growAndShrink {
            0% { transform: scale(0); opacity: 1; }
            50% { transform: scale(1.1); opacity: 1; border-radius: 15%; }
            90% { transform: scale(1.1); opacity: 1; border-radius: 15%; } 
            100% { transform: scale(0); opacity: 0; }
        }

        .notes-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 0;
            padding: 0;
        }

        .note {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #ffffff;
            font-weight: bold;
            background: none;
            border-radius: 0;
        }

        .note.highlighted {
            background: #f57c00;
            color: #ffffff;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            width: 100%;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .action-button {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .erase-button {
            background: #d32f2f;
            color: #ffffff;
            border: 2px solid #f44336;
            font-size: 18px;
        }

        .erase-button:hover:not(:disabled) {
            background: #f44336;
            border-color: #f66;
        }

        .notes-button {
            background: #404040;
            color: #ffffff;
            border: 2px solid #606060;
            position: relative;
        }

        .notes-button.active {
            background: #7b1fa2;
            color: #ffffff;
            border: 2px solid #ce93d8;
            box-shadow: 0 0 12px rgba(123, 31, 162, 0.6), 0 0 24px rgba(123, 31, 162, 0.3);
            transform: scale(1.15);
        }

        .notes-button.active::after {
            content: '';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 8px;
            height: 8px;
            background: #4caf50;
            border-radius: 50%;
            border: 1px solid #ffffff;
        }

        .undo-button {
            background: #404040;
            color: #ffffff;
            border: 2px solid #606060;
        }

        .undo-button:hover:not(:disabled) {
            background: #505050;
            border-color: #707070;
        }

        .undo-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-button:hover:not(:disabled) {
            opacity: 0.8;
        }

        .number-buttons {
            display: flex;
            gap: 4px;
            width: 100%;
            padding: 0;
        }

        .number-button {
            flex: 1;
            height: 70px;
            border: 2px solid transparent;
            border-radius: 5px;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            background: #404040;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .number-button:hover:not(.highlighted) {
            background: #505050;
        }

        .number-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .number-button.highlighted {
            background: #ff9800 !important;
            border: 2px solid #ffb74d !important;
            box-shadow: inset 0 0 8px rgba(255, 193, 7, 0.3) !important;
        }

        .remaining-count {
            font-size: 10px;
            color: #b0b0b0;
            font-weight: bold;
            margin-top: 2px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
        }

        .modal.show { display: flex; }

        .modal-content {
            background: #2d2d2d;
            color: #ffffff;
            margin: auto;
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            width: 90%;
            border: 1px solid #404040;
        }

        .modal-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffffff;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .btn {
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
        }

        .btn-primary { 
            background: #2196f3; 
            color: white; 
        }
        
        .btn-primary:hover { 
            background: #1976d2; 
        }

        .btn-secondary { 
            background: #404040; 
            color: #ffffff; 
        }
        
        .btn-secondary:hover { 
            background: #505050; 
        }

        .btn-danger {
            background: #d32f2f;
            color: #ffffff;
        }

        .btn-danger:hover {
            background: #f44336;
        }

        .option-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #404040;
        }

        .option-item:last-child { border-bottom: none; }

        .option-item.clickable {
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .option-item.clickable:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #666666;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: #2d2d2d;
            color: #4caf50;
            font-weight: bold;
        }

        .checkbox.checked {
            background: #4caf50;
            border-color: #4caf50;
            color: #ffffff;
        }

        .option-details {
            flex: 1;
            margin-left: 12px;
        }

        .option-title {
            font-weight: bold;
            font-size: 15px;
            margin-bottom: 3px;
            color: #ffffff;
        }

        .option-subtitle {
            font-size: 11px;
            color: #b0b0b0;
        }

        .export-textarea {
            width: 100%;
            height: 200px;
            background: #1e1e1e;
            border: 1px solid #404040;
            border-radius: 5px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            margin: 10px 0;
            resize: vertical;
        }

        .hidden { display: none !important; }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #ffffff;
        }

        .loading-progress {
            margin-top: 10px;
            font-size: 12px;
            color: #b0b0b0;
            text-align: center;
        }

        @media (max-width: 400px) {
            .sudoku-grid {
                width: calc(100vw - 15px);
                height: calc(100vw - 15px);
                max-width: 385px;
                max-height: 385px;
            }
            
            .sudoku-grid.with-coordinates {
                width: calc(100vw - 50px);
                height: calc(100vw - 50px);
                max-width: 350px;
                max-height: 350px;
            }
            
            .game-screen {
                padding: 10px;
                gap: 15px;
            }

            .game-screen.with-coordinates {
                padding-top: 40px;
            }
            
            .number-buttons {
                gap: 2px;
            }
            
            .number-button {
                height: 60px;
                font-size: 18px;
            }

            .coordinate-label {
                font-size: 8px;
                width: 14px;
                height: 14px;
            }

            .row-coordinates {
                left: -18px;
                width: 14px;
            }

            .col-coordinates {
                top: -18px;
                height: 14px;
            }

            .sudoku-container {
                margin: 0;
                width: 100%;
            }
            
            .sudoku-cell {
                font-size: 28px;
            }

            .note {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div id="menuScreen" class="screen">
            <div class="menu-screen">
                <div class="main-title">SUDOKU</div>
                <div class="warning-text">By Victor Burtman</div>
                
                <button class="option-button" onclick="showOptionsModal()">
                    <span>⚙️</span>
                    <span>Options</span>
                </button>
                
                <button class="difficulty-button" style="background: #4caf50; color: white;" onclick="startGame(0.2, 'Very Easy')">Very Easy</button>
                <button class="difficulty-button" style="background: #8bc34a; color: white;" onclick="startGame(0.35, 'Easy')">Easy</button>
                <button class="difficulty-button" style="background: #ff9800; color: white;" onclick="startGame(0.5, 'Medium')">Medium</button>
                <button class="difficulty-button" style="background: #ff5722; color: white;" onclick="startGame(0.65, 'Hard')">Hard</button>
                <button class="difficulty-button" style="background: #f44336; color: white;" onclick="startGame(0.8, 'Expert')">Expert</button>
            </div>
        </div>

        <div id="gameScreen" class="screen hidden">
            <div class="app-bar">
                <div class="app-bar-top-row">
                    <div class="game-info">
                        <button class="back-button" onclick="goBackToMenu()">←</button>
                        <div class="app-title" id="gameTitle">Sudoku</div>
                    </div>
                    <div class="game-actions">
                        <div id="errorDisplay" class="error-display hidden"></div>
                        <button class="btn btn-secondary" onclick="showOptionsModal()">⚙️</button>
                        <button class="btn btn-secondary" onclick="confirmResetGame()">🔄</button>
                    </div>
                </div>
                <div class="app-bar-bottom-row">
                    <div id="timerDisplay" class="timer-display hidden">
                        <span>⏱️</span>
                        <span id="timerText">0s</span>
                    </div>
                </div>
            </div>
            
            <div class="game-screen" onclick="handleGameAreaClick(event)">
                <div class="sudoku-container">
                    <div class="sudoku-grid-wrapper">
                        <div id="coordinatesContainer" class="coordinates-container hidden">
                            <div class="row-coordinates">
                                <div class="coordinate-label">R1</div>
                                <div class="coordinate-label">R2</div>
                                <div class="coordinate-label">R3</div>
                                <div class="coordinate-label">R4</div>
                                <div class="coordinate-label">R5</div>
                                <div class="coordinate-label">R6</div>
                                <div class="coordinate-label">R7</div>
                                <div class="coordinate-label">R8</div>
                                <div class="coordinate-label">R9</div>
                            </div>
                            <div class="col-coordinates">
                                <div class="coordinate-label">C1</div>
                                <div class="coordinate-label">C2</div>
                                <div class="coordinate-label">C3</div>
                                <div class="coordinate-label">C4</div>
                                <div class="coordinate-label">C5</div>
                                <div class="coordinate-label">C6</div>
                                <div class="coordinate-label">C7</div>
                                <div class="coordinate-label">C8</div>
                                <div class="coordinate-label">C9</div>
                            </div>
                        </div>
                        <div class="sudoku-grid" id="sudokuGrid"></div>
                    </div>
                </div>
                
                <div class="controls">
                    <div class="action-buttons">
                        <button class="action-button undo-button" id="undoButton" onclick="undoLastAction()">⟲</button>
                        <button class="action-button erase-button" onclick="placeNumber(0)">×</button>
                        <button class="action-button notes-button" id="notesButton" onclick="toggleNotesMode()">✏️</button>
                    </div>
                    
                    <div class="number-buttons" id="numberButtons"></div>
                </div>
            </div>
        </div>

        <div id="optionsModal" class="modal">
            <div class="modal-content">
                <div class="modal-title">Game Options</div>
                <div id="optionsContent"></div>
                <div class="modal-actions">
                    <button class="btn btn-primary" onclick="closeOptionsModal()">Close</button>
                </div>
            </div>
        </div>

        <div id="gameOverModal" class="modal">
            <div class="modal-content">
                <div class="modal-title" id="gameOverTitle"></div>
                <div id="gameOverContent"></div>
                <div class="modal-actions" id="gameOverActions"></div>
            </div>
        </div>

        <div id="loadingModal" class="modal">
            <div class="modal-content">
                <div class="loading">
                    <div style="margin-right: 10px;">⏳</div>
                    <div id="loadingText">Generating grid...</div>
                </div>
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>

        <div id="exportModal" class="modal">
            <div class="modal-content">
                <div class="modal-title">Export Current State</div>
                <p>The current state of your Sudoku has been copied to your clipboard:</p>
                <textarea class="export-textarea" id="exportTextarea" readonly></textarea>
                <div class="modal-actions">
                    <button class="btn btn-primary" onclick="closeExportModal()">Close</button>
                </div>
            </div>
        </div>

        <div id="resetConfirmModal" class="modal">
            <div class="modal-content">
                <div class="modal-title">⚠️ Reset Game</div>
                <p>Are you sure you want to reset the current game?</p>
                <p style="color: #ff9800; font-size: 14px; margin-top: 10px;">All your progress will be lost!</p>
                <div class="modal-actions">
                    <button class="btn btn-secondary" onclick="closeResetConfirmModal()">Cancel</button>
                    <button class="btn btn-danger" onclick="confirmReset()">Reset Game</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let gameState = {
            currentGrid: [],
            originalGrid: [],
            solvedGrid: [],
            errorGrid: [],
            notesGrid: [],
            selectedRow: null,
            selectedCol: null,
            errorCount: 0,
            gameWon: false,
            gameLost: false,
            notesMode: false,
            startTime: null,
            elapsedTime: 0,
            gameTimer: null,
            difficulty: '',
            source: '',
            actionHistory: [],
            highlightedNumber: null,
            isInitialRender: false // Flag for initial fade-in animation
        };

        let options = {
            indicativeMode: false,
            highlightMode: true,
            showTimer: true,
            showCoordinates: false,
            useAnimations: true,
            soundEnabled: true
        };

        // Sudoku Generator
        class SudokuGenerator {
            constructor() {
                this.SIZE = 9;
                this.EMPTY = 0;
            }

            generate(difficulty = 0.5) {
                this.updateLoadingProgress("Generating complete grid...");
                const completeGrid = this.generateCompleteGrid();
                
                this.updateLoadingProgress("Creating puzzle with unique solution...");
                const puzzle = this.createPuzzleWithUniqueCheck(completeGrid, difficulty);
                
                this.updateLoadingProgress("Validating puzzle...");
                return {
                    puzzle: puzzle,
                    solution: completeGrid
                };
            }

            updateLoadingProgress(text) {
                const progressEl = document.getElementById('loadingProgress');
                if (progressEl) {
                    progressEl.textContent = text;
                }
            }

            generateCompleteGrid() {
                const grid = Array(this.SIZE).fill().map(() => Array(this.SIZE).fill(this.EMPTY));
                this.fillGrid(grid);
                return grid;
            }

            fillGrid(grid) {
                return this.fillGridRecursive(grid, 0, 0);
            }

            fillGridRecursive(grid, row, col) {
                if (row === this.SIZE) return true;
                
                const nextRow = col === this.SIZE - 1 ? row + 1 : row;
                const nextCol = col === this.SIZE - 1 ? 0 : col + 1;

                if (grid[row][col] !== this.EMPTY) {
                    return this.fillGridRecursive(grid, nextRow, nextCol);
                }

                const numbers = this.shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                for (const num of numbers) {
                    if (this.isValid(grid, row, col, num)) {
                        grid[row][col] = num;
                        if (this.fillGridRecursive(grid, nextRow, nextCol)) {
                            return true;
                        }
                        grid[row][col] = this.EMPTY;
                    }
                }
                return false;
            }

            isValid(grid, row, col, num) {
                for (let c = 0; c < this.SIZE; c++) {
                    if (grid[row][c] === num) return false;
                }
                
                for (let r = 0; r < this.SIZE; r++) {
                    if (grid[r][col] === num) return false;
                }
                
                const boxRow = Math.floor(row / 3) * 3;
                const boxCol = Math.floor(col / 3) * 3;
                for (let r = boxRow; r < boxRow + 3; r++) {
                    for (let c = boxCol; c < boxCol + 3; c++) {
                        if (grid[r][c] === num) return false;
                    }
                }
                return true;
            }

            createPuzzleWithUniqueCheck(completeGrid, difficulty) {
                const puzzle = completeGrid.map(row => [...row]);
                const positions = this.getAllPositions();
                this.shuffleArray(positions);

                const targetEmpty = Math.floor(81 * difficulty);
                let removedCount = 0;
                let attempts = 0;
                const maxAttempts = positions.length;

                for (let i = 0; i < positions.length && removedCount < targetEmpty && attempts < maxAttempts; i++) {
                    const [row, col] = positions[i];
                    const backup = puzzle[row][col];
                    puzzle[row][col] = this.EMPTY;
                    attempts++;

                    if (this.hasUniqueSolution(puzzle)) {
                        removedCount++;
                    } else {
                        puzzle[row][col] = backup;
                    }

                    if (attempts % 10 === 0) {
                        this.updateLoadingProgress(`Testing cell ${attempts}/${maxAttempts}...`);
                    }
                }

                return puzzle;
            }

            getAllPositions() {
                const positions = [];
                for (let r = 0; r < this.SIZE; r++) {
                    for (let c = 0; c < this.SIZE; c++) {
                        positions.push([r, c]);
                    }
                }
                return positions;
            }

            hasUniqueSolution(grid) {
                const gridCopy = grid.map(row => [...row]);
                let solutionCount = 0;
                
                const solve = (g, row = 0, col = 0) => {
                    if (solutionCount > 1) return false;
                    
                    if (row === this.SIZE) {
                        solutionCount++;
                        return solutionCount === 1;
                    }
                    
                    const nextRow = col === this.SIZE - 1 ? row + 1 : row;
                    const nextCol = col === this.SIZE - 1 ? 0 : col + 1;

                    if (g[row][col] !== this.EMPTY) {
                        return solve(g, nextRow, nextCol);
                    }

                    for (let num = 1; num <= 9; num++) {
                        if (this.isValid(g, row, col, num)) {
                            g[row][col] = num;
                            solve(g, nextRow, nextCol);
                            g[row][col] = this.EMPTY;
                        }
                    }
                    return false;
                };

                solve(gridCopy);
                return solutionCount === 1;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        const sudokuGenerator = new SudokuGenerator();
        
        const soundManager = {
            sounds: {},
            popSounds: [],
            isInitialized: false,
            soundConfig: {
                intro: 'sounds/intro.mp3',
                error: 'sounds/error.mp3',
                victory: 'sounds/victory.mp3',
                button1: 'sounds/button1.mp3',
                button2: 'sounds/button2.mp3',
                // Add or remove file paths here to change the available pop sounds
                popFiles: [
                    'sounds/pop4.mp3',
                    'sounds/pop5.mp3'
                ]
            },

            init: function() {
                if (this.isInitialized) return;
                this.loadSounds();
                this.isInitialized = true;

                // Unlock/warm-up audio elements to reduce latency on first play
                const allSounds = [...Object.values(this.sounds), ...this.popSounds];
                allSounds.forEach(sound => {
                    sound.volume = 0;
                    const playPromise = sound.play();

                    if (playPromise !== undefined) {
                        playPromise.then(_ => {
                            sound.pause();
                            sound.currentTime = 0;
                            sound.volume = 1;
                        }).catch(error => {
                            // Can be ignored. It's often a file not found error, 
                            // or the browser blocking autoplay for an element.
                        });
                    }
                });
                console.log('Sound manager initialized and audio unlocked.');
            },

            loadSounds: function() {
                const config = this.soundConfig;
                // Load single sounds
                this.sounds['intro'] = new Audio(config.intro);
                this.sounds['error'] = new Audio(config.error);
                this.sounds['victory'] = new Audio(config.victory);
                this.sounds['button1'] = new Audio(config.button1);
                this.sounds['button2'] = new Audio(config.button2);

                // Preload single sounds
                for(const key in this.sounds) {
                    this.sounds[key].preload = 'auto';
                }

                // Load pop sounds from the popFiles array
                config.popFiles.forEach(filePath => {
                    const popSound = new Audio(filePath);
                    popSound.preload = 'auto';
                    this.popSounds.push(popSound);
                });
            },

            playSound: function(name) {
                if (!options.soundEnabled || !this.isInitialized) return;

                let soundToPlay = null;

                if (name === 'pop') {
                    if (this.popSounds.length > 0) {
                        const randomIndex = Math.floor(Math.random() * this.popSounds.length);
                        soundToPlay = this.popSounds[randomIndex];
                    }
                } else if (this.sounds[name]) {
                    soundToPlay = this.sounds[name];
                }
                
                if(soundToPlay) {
                    soundToPlay.currentTime = 0;
                    soundToPlay.play().catch(e => console.error(`Sound play failed for ${name}:`, e));
                }
            }
        };

        // Storage functions
        function loadOptions() {
            const saved = localStorage.getItem('sudoku_options');
            if (saved) {
                try {
                    options = {...options, ...JSON.parse(saved)};
                } catch (e) {
                    console.log('Error loading options:', e);
                }
            }
        }

        function saveOptions() {
            localStorage.setItem('sudoku_options', JSON.stringify(options));
        }

        function saveGameState() {
            if (gameState.originalGrid.length === 0) return;
            
            if (gameState.startTime && !gameState.gameWon && !gameState.gameLost) {
                gameState.elapsedTime = Date.now() - gameState.startTime;
            }

            const notesGridForSave = gameState.notesGrid.map(row =>
                row.map(noteSet => Array.from(noteSet))
            );
            
            const saveData = {
                originalGrid: gameState.originalGrid,
                currentGrid: gameState.currentGrid,
                solvedGrid: gameState.solvedGrid,
                notesGrid: notesGridForSave,
                selectedRow: gameState.selectedRow,
                selectedCol: gameState.selectedCol,
                errorCount: gameState.errorCount,
                gameWon: gameState.gameWon,
                gameLost: gameState.gameLost,
                notesMode: gameState.notesMode,
                startTime: gameState.startTime,
                elapsedTime: gameState.elapsedTime,
                difficulty: gameState.difficulty,
                source: gameState.source,
                actionHistory: gameState.actionHistory,
                highlightedNumber: gameState.highlightedNumber
            };
            
            localStorage.setItem('sudoku_saved_game', JSON.stringify(saveData));
        }

        function loadSavedGame() {
            const saved = localStorage.getItem('sudoku_saved_game');
            if (!saved) return false;
            
            try {
                const saveData = JSON.parse(saved);
                
                gameState.originalGrid = saveData.originalGrid;
                gameState.currentGrid = saveData.currentGrid;
                gameState.solvedGrid = saveData.solvedGrid || [];
                gameState.selectedRow = saveData.selectedRow;
                gameState.selectedCol = saveData.selectedCol;
                gameState.errorCount = saveData.errorCount || 0;
                gameState.gameWon = saveData.gameWon || false;
                gameState.gameLost = saveData.gameLost || false;
                gameState.notesMode = saveData.notesMode || false;
                gameState.startTime = saveData.startTime;
                gameState.elapsedTime = saveData.elapsedTime || 0;
                gameState.difficulty = saveData.difficulty || '';
                gameState.source = saveData.source || 'Local Generator';
                gameState.actionHistory = saveData.actionHistory || [];
                gameState.highlightedNumber = saveData.highlightedNumber;
                
                gameState.startTime = Date.now() - gameState.elapsedTime;

                gameState.notesGrid = saveData.notesGrid.map(row =>
                    row.map(noteArray => new Set(noteArray))
                );
                
                gameState.errorGrid = Array(9).fill().map(() => Array(9).fill(false));
                if (options.indicativeMode) {
                    updateErrors();
                }
                
                document.getElementById('gameTitle').textContent = gameState.difficulty;
                if (gameState.notesMode) {
                    document.getElementById('notesButton').classList.add('active');
                } else {
                    document.getElementById('notesButton').classList.remove('active');
                }
                
                return true;
            } catch (e) {
                console.error('Error loading saved game:', e);
                localStorage.removeItem('sudoku_saved_game');
                return false;
            }
        }

        function clearSavedGame() {
            localStorage.removeItem('sudoku_saved_game');
        }

        function updateCoordinatesDisplay() {
            const coordinatesContainer = document.getElementById('coordinatesContainer');
            const sudokuGrid = document.getElementById('sudokuGrid');
            const gameScreen = document.querySelector('.game-screen');
            
            if (options.showCoordinates) {
                coordinatesContainer.classList.remove('hidden');
                sudokuGrid.classList.add('with-coordinates');
                gameScreen.classList.add('with-coordinates');
            } else {
                coordinatesContainer.classList.add('hidden');
                sudokuGrid.classList.remove('with-coordinates');
                gameScreen.classList.remove('with-coordinates');
            }
        }

        // Main functions - declared globally
        window.showScreen = function(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(screenId).classList.remove('hidden');
        }
        
        window.goBackToMenu = function() {
            soundManager.playSound('button2');
            showScreen('menuScreen');
        }

        window.startGame = function(difficulty, label) {
            soundManager.playSound('button2');
            document.getElementById('loadingModal').classList.add('show');
            document.getElementById('loadingText').textContent = 'Generating grid...';
            document.getElementById('loadingProgress').textContent = '';
            
            setTimeout(() => {
                try {
                    const result = sudokuGenerator.generate(difficulty);
                    initializeGame(result.puzzle, result.solution, label, difficulty);
                    showScreen('gameScreen');
                } catch (e) {
                    alert('Error generating Sudoku grid. Please try again.');
                    console.error('Sudoku generation error:', e);
                } finally {
                    document.getElementById('loadingModal').classList.remove('show');
                }
            }, 200);
        }

        window.showOptionsModal = function() {
            soundManager.playSound('button1');
            const modal = document.getElementById('optionsModal');
            const content = document.getElementById('optionsContent');
            
            const inGame = !document.getElementById('gameScreen').classList.contains('hidden');

            content.innerHTML = `
                ${inGame ? `
                <div class="option-item clickable" onclick="shareGrid(); closeOptionsModal();">
                    <div style="width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 16px;">📤</div>
                    <div class="option-details">
                        <div class="option-title">Share This Grid</div>
                        <div class="option-subtitle">Generate a link to share this puzzle with friends</div>
                    </div>
                </div>
                <div class="option-item clickable" onclick="exportCurrentState(); closeOptionsModal();">
                    <div style="width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 16px;">📋</div>
                    <div class="option-details">
                        <div class="option-title">Export Current State</div>
                        <div class="option-subtitle">Copy current grid state as JSON for AI assistance</div>
                    </div>
                </div>
                ` : ''}
                <div class="option-item">
                    <div class="checkbox ${options.indicativeMode ? 'checked' : ''}" 
                         onclick="toggleOption('indicativeMode', this)">
                        ${options.indicativeMode ? '✓' : ''}
                    </div>
                    <div class="option-details">
                        <div class="option-title">Smart Hint Mode</div>
                        <div class="option-subtitle">Shows errors in red based on correct solution. 3 errors = game over</div>
                    </div>
                </div>
                <div class="option-item">
                    <div class="checkbox ${options.highlightMode ? 'checked' : ''}" 
                         onclick="toggleOption('highlightMode', this)">
                        ${options.highlightMode ? '✓' : ''}
                    </div>
                    <div class="option-details">
                        <div class="option-title">Highlight</div>
                        <div class="option-subtitle">Highlights row/column and identical numbers</div>
                    </div>
                </div>
                <div class="option-item">
                    <div class="checkbox ${options.showTimer ? 'checked' : ''}" 
                         onclick="toggleOption('showTimer', this)">
                        ${options.showTimer ? '✓' : ''}
                    </div>
                    <div class="option-details">
                        <div class="option-title">Show Timer</div>
                        <div class="option-subtitle">Shows elapsed time during game</div>
                    </div>
                </div>
                <div class="option-item">
                    <div class="checkbox ${options.showCoordinates ? 'checked' : ''}" 
                         onclick="toggleOption('showCoordinates', this)">
                        ${options.showCoordinates ? '✓' : ''}
                    </div>
                    <div class="option-details">
                        <div class="option-title">Show Coordinates</div>
                        <div class="option-subtitle">Display row/column numbers for easier debugging</div>
                    </div>
                </div>
                <div class="option-item">
                    <div class="checkbox ${options.useAnimations ? 'checked' : ''}" 
                         onclick="toggleOption('useAnimations', this)">
                        ${options.useAnimations ? '✓' : ''}
                    </div>
                    <div class="option-details">
                        <div class="option-title">Enable Animations</div>
                        <div class="option-subtitle">Enables visual effects for completed rows, columns & blocks</div>
                    </div>
                </div>
                <div class="option-item">
                    <div class="checkbox ${options.soundEnabled ? 'checked' : ''}" 
                         onclick="toggleOption('soundEnabled', this)">
                        ${options.soundEnabled ? '✓' : ''}
                    </div>
                    <div class="option-details">
                        <div class="option-title">Enable Sounds</div>
                        <div class="option-subtitle">Enables sound effects during the game</div>
                    </div>
                </div>
            `;

            modal.classList.add('show');
        }

        window.closeOptionsModal = function() {
            soundManager.playSound('button2');
            document.getElementById('optionsModal').classList.remove('show');
        }

        window.toggleOption = function(optionName, element) {
            options[optionName] = !options[optionName];
            soundManager.playSound('button2');
            saveOptions();
            
            // Manually update the checkbox UI to avoid re-rendering the whole modal
            if (element) {
                if (options[optionName]) {
                    element.classList.add('checked');
                    element.innerHTML = '✓';
                } else {
                    element.classList.remove('checked');
                    element.innerHTML = '';
                }
            }
            
            if (optionName === 'showTimer') {
                clearInterval(gameState.gameTimer);
                if (options.showTimer && !gameState.gameWon && !gameState.gameLost) {
                    startTimer();
                }
            }
            
            if (optionName === 'showCoordinates') {
                updateCoordinatesDisplay();
            }
            
            if (document.getElementById('gameScreen').classList.contains('hidden') === false) {
                renderGame();
            }
        }

        window.confirmResetGame = function() {
            soundManager.playSound('button1');
            document.getElementById('resetConfirmModal').classList.add('show');
        }

        window.closeResetConfirmModal = function() {
            document.getElementById('resetConfirmModal').classList.remove('show');
        }

        window.confirmReset = function() {
            closeResetConfirmModal();
            resetGame();
        }

        window.undoLastAction = function() {
            if (gameState.actionHistory.length === 0) return;
            soundManager.playSound('button1');
            
            const lastAction = gameState.actionHistory.pop();
            
            if (lastAction.type === 'number') {
                gameState.currentGrid[lastAction.row][lastAction.col] = lastAction.oldValue;
                if (lastAction.oldNotes) {
                    gameState.notesGrid[lastAction.row][lastAction.col] = new Set(lastAction.oldNotes);
                } else {
                    gameState.notesGrid[lastAction.row][lastAction.col] = new Set();
                }
            } else if (lastAction.type === 'note') {
                if (lastAction.action === 'add') {
                    gameState.notesGrid[lastAction.row][lastAction.col].delete(lastAction.number);
                } else {
                    gameState.notesGrid[lastAction.row][lastAction.col].add(lastAction.number);
                }
            }
            
            if (options.indicativeMode) {
                updateErrors();
            }
            
            updateUndoButton();
            renderGame();
            saveGameState();
        }

        window.placeNumber = function(number) {
            if (gameState.selectedRow === null || gameState.selectedCol === null) {
                if (number !== 0) {
                    gameState.highlightedNumber = gameState.highlightedNumber === number ? null : number;
                    renderGame();
                }
                return;
            }
            
            if (gameState.gameWon || gameState.gameLost) return;
            
            const row = gameState.selectedRow;
            const col = gameState.selectedCol;

            if (gameState.originalGrid[row][col] !== 0) return;
            
            if (number === 0) { // Erase button
                soundManager.playSound('button1');
            }

            if (options.indicativeMode && 
                gameState.currentGrid[row][col] !== 0 && 
                gameState.solvedGrid.length > 0 && 
                gameState.currentGrid[row][col] === gameState.solvedGrid[row][col]) {
                return;
            }

            if (gameState.notesMode && number !== 0) {
                const hasExistingNote = gameState.notesGrid[row][col].has(number);
                
                if (options.indicativeMode && !hasExistingNote) {
                    let hasConflict = false;
                    for (let c = 0; c < 9; c++) { if (gameState.currentGrid[row][c] === number) { hasConflict = true; break; } }
                    if (!hasConflict) { for (let r = 0; r < 9; r++) { if (gameState.currentGrid[r][col] === number) { hasConflict = true; break; } } }
                    if (!hasConflict) {
                        const startRow = Math.floor(row / 3) * 3;
                        const startCol = Math.floor(col / 3) * 3;
                        for (let r = startRow; r < startRow + 3; r++) {
                            for (let c = startCol; c < startCol + 3; c++) {
                                if (gameState.currentGrid[r][c] === number) { hasConflict = true; break; }
                            }
                            if (hasConflict) break;
                        }
                    }
                    
                    if (hasConflict) {
                        flashConflictingCells(row, col, number);
                        return;
                    }
                }

                const action = { type: 'note', row, col, number, action: hasExistingNote ? 'remove' : 'add' };
                saveAction(action);

                if (hasExistingNote) {
                    gameState.notesGrid[row][col].delete(number);
                } else {
                    gameState.notesGrid[row][col].add(number);
                }
            } 
            else {
                const oldValue = gameState.currentGrid[row][col];
                if (oldValue === number && number !== 0) return;

                const action = { type: 'number', row, col, oldValue, newValue: number, oldNotes: gameState.notesGrid[row][col].size > 0 ? Array.from(gameState.notesGrid[row][col]) : null };
                saveAction(action);

                gameState.currentGrid[row][col] = number;
                
                if (number !== 0) {
                    gameState.notesGrid[row][col].clear();
                }

                if (options.indicativeMode && number !== 0) {
                    if (isCorrectMove(row, col, number)) {
                        soundManager.playSound('pop');
                    } else {
                        if (oldValue === 0) { 
                            soundManager.playSound('error');
                            gameState.errorCount++;
                            if (gameState.errorCount >= 3) {
                                gameState.gameLost = true;
                                gameState.elapsedTime = Date.now() - gameState.startTime;
                                showGameOverModal(false);
                                renderGame();
                                saveGameState();
                                return;
                            }
                        }
                    }
                } else if (number !== 0) {
                    soundManager.playSound('pop');
                }
            }

            if (options.indicativeMode) {
                updateErrors();
                cleanObsoleteNotes();
            }

            const isNowComplete = isSudokuComplete();
            const unitsToAnimate = options.indicativeMode ? getCompletedUnits(row, col) : [];

            if (isNowComplete) {
                gameState.gameWon = true;
                gameState.elapsedTime = Date.now() - gameState.startTime;
                clearInterval(gameState.gameTimer);

                renderGame();
                saveGameState();
                
                let completionAnimTime = 0;
                if (options.useAnimations && unitsToAnimate.length > 0) {
                    animateUnitsSequentially(unitsToAnimate);
                    completionAnimTime = Math.max(0, unitsToAnimate.length - 1) * 700 + 1200;
                }
                
                setTimeout(triggerWinAnimation, completionAnimTime + 100);
                
                return;
            } else {
                 if (options.useAnimations) {
                    animateUnitsSequentially(unitsToAnimate);
                 }
            }

            renderGame();
            saveGameState();
        }

        window.toggleNotesMode = function() {
            soundManager.playSound('button1');
            gameState.notesMode = !gameState.notesMode;
            const button = document.getElementById('notesButton');
            
            if (gameState.notesMode) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
            
            renderNumberButtons();
        }

        window.handleGameAreaClick = function(event) {
            if (gameState.isInitialRender) return;

            if (!event.target.classList.contains('sudoku-cell') && 
                !event.target.closest('.sudoku-cell') &&
                !event.target.classList.contains('action-button') &&
                !event.target.classList.contains('number-button') &&
                !event.target.closest('.action-button') &&
                !event.target.closest('.number-button')) {
                gameState.selectedRow = null;
                gameState.selectedCol = null;
                gameState.highlightedNumber = null;
                renderGame();
            }
        }

        window.closeGameOverModal = function() {
            document.getElementById('gameOverModal').classList.remove('show');
        }

        window.exportCurrentState = function() {
            const notesGridForExport = gameState.notesGrid.map(row =>
                row.map(noteSet => Array.from(noteSet).sort())
            );

            const exportData = {
                difficulty: gameState.difficulty,
                originalGrid: gameState.originalGrid,
                currentGrid: gameState.currentGrid,
                notesGrid: notesGridForExport
            };

            const jsonString = JSON.stringify(exportData, null, 2);
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(jsonString).then(() => {
                    showExportModal(jsonString, true);
                }).catch(() => {
                    showExportModal(jsonString, false);
                });
            } else {
                showExportModal(jsonString, false);
            }
        }

        window.closeExportModal = function() {
            document.getElementById('exportModal').classList.remove('show');
        }

        window.shareGrid = function() {
            if (!gameState.originalGrid || gameState.originalGrid.length === 0) {
                alert('No grid to share!');
                return;
            }

            const encodedGrid = encodeGrid(gameState.originalGrid, gameState.difficulty, gameState.difficulty);
            const shareUrl = window.location.origin + window.location.pathname + '?grid=' + encodedGrid;
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl).then(() => {
                    showShareModal(shareUrl, true);
                }).catch(() => {
                    showShareModal(shareUrl, false);
                });
            } else {
                showShareModal(shareUrl, false);
            }
        }

        function initializeGame(grid, solution, difficultyLabel, difficulty) {
            gameState.originalGrid = grid.map(row => [...row]);
            gameState.currentGrid = grid.map(row => [...row]);
            gameState.solvedGrid = solution.map(row => [...row]);
            gameState.errorGrid = Array(9).fill().map(() => Array(9).fill(false));
            gameState.notesGrid = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
            gameState.selectedRow = null;
            gameState.selectedCol = null;
            gameState.errorCount = 0;
            gameState.gameWon = false;
            gameState.gameLost = false;
            gameState.notesMode = false;
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.difficulty = difficultyLabel;
            gameState.source = 'Local Generator';
            gameState.actionHistory = [];
            gameState.isInitialRender = true;

            document.getElementById('gameTitle').textContent = difficultyLabel;
            document.getElementById('notesButton').classList.remove('active');

            clearInterval(gameState.gameTimer);
            if (options.showTimer) {
                startTimer();
            }

            soundManager.playSound('intro');

            updateCoordinatesDisplay();
            saveGameState();
            renderGame();
        }

        function startTimer() {
            gameState.gameTimer = setInterval(() => {
                if (!gameState.gameWon && !gameState.gameLost) {
                    gameState.elapsedTime = Date.now() - gameState.startTime;
                    updateTimerDisplay();
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const timerEl = document.getElementById('timerDisplay');
            if (options.showTimer) {
                timerEl.classList.remove('hidden');
                document.getElementById('timerText').textContent = formatTime(gameState.elapsedTime);
            } else {
                timerEl.classList.add('hidden');
            }
        }

        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            if (hours > 0) {
                return `${hours}h ${(minutes % 60).toString().padStart(2, '0')}m ${(seconds % 60).toString().padStart(2, '0')}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${(seconds % 60).toString().padStart(2, '0')}s`;
            } else {
                return `${seconds}s`;
            }
        }

        function flashConflictingCells(row, col, number) {
            soundManager.playSound('error');
            const conflictCells = [];
            
            for (let c = 0; c < 9; c++) {
                if (gameState.currentGrid[row][c] === number) {
                    conflictCells.push([row, c]);
                }
            }
            
            for (let r = 0; r < 9; r++) {
                if (gameState.currentGrid[r][col] === number) {
                    conflictCells.push([r, col]);
                }
            }
            
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                    if (gameState.currentGrid[r][c] === number) {
                        conflictCells.push([r, c]);
                    }
                }
            }
            
            conflictCells.forEach(([r, c]) => {
                const cellIndex = r * 9 + c;
                const cell = document.getElementById('sudokuGrid').children[cellIndex];
                if (cell) {
                    cell.classList.add('flash-conflict');
                    setTimeout(() => {
                        cell.classList.remove('flash-conflict');
                    }, 600);
                }
            });
        }

        function renderGame() {
            renderGrid();
            renderNumberButtons();
            updateErrorDisplay();
            updateTimerDisplay();
            updateUndoButton();
            updateCoordinatesDisplay();
        }

        function getCompletedUnits(row, col) {
            if (!options.indicativeMode || !gameState.solvedGrid.length) return [];
            
            const completedUnits = [];

            let rowComplete = true;
            for (let c = 0; c < 9; c++) {
                if (gameState.currentGrid[row][c] === 0 || gameState.currentGrid[row][c] !== gameState.solvedGrid[row][c]) {
                    rowComplete = false; break;
                }
            }
            if (rowComplete) {
                const cells = [];
                for (let c = 0; c < 9; c++) cells.push([row, c]);
                completedUnits.push(cells);
            }

            let colComplete = true;
            for (let r = 0; r < 9; r++) {
                if (gameState.currentGrid[r][col] === 0 || gameState.currentGrid[r][col] !== gameState.solvedGrid[r][col]) {
                    colComplete = false; break;
                }
            }
            if (colComplete) {
                const cells = [];
                for (let r = 0; r < 9; r++) cells.push([r, col]);
                completedUnits.push(cells);
            }

            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            let boxComplete = true;
            for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                    if (gameState.currentGrid[r][c] === 0 || gameState.currentGrid[r][c] !== gameState.solvedGrid[r][c]) {
                        boxComplete = false; break;
                    }
                }
                if (!boxComplete) break;
            }
            if (boxComplete) {
                const cells = [];
                for (let r = startRow; r < startRow + 3; r++) {
                    for (let c = startCol; c < startCol + 3; c++) cells.push([r, c]);
                }
                completedUnits.push(cells);
            }
            
            return completedUnits;
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                if (gameState.gameTimer) {
                    clearInterval(gameState.gameTimer);
                    gameState.elapsedTime = Date.now() - gameState.startTime;
                }
            } 
            else {
                if (!gameState.gameWon && !gameState.gameLost && gameState.startTime) {
                    gameState.startTime = Date.now() - gameState.elapsedTime;
                    startTimer();
                }
            }
        }

        function animateUnitsSequentially(completedUnits) {
             if (completedUnits.length > 0) {
                let cumulativeDelay = 0;
                completedUnits.forEach(unit => {
                    setTimeout(() => {
                        triggerCompletionAnimation(unit);
                    }, cumulativeDelay);
                    cumulativeDelay += 700;
                });
            }
        }

        function triggerCompletionAnimation(cells) {
            const gridEl = document.getElementById('sudokuGrid');
            cells.forEach(([row, col], index) => {
                setTimeout(() => {
                    const cellIndex = row * 9 + col;
                    const cell = gridEl.children[cellIndex];
                    if (cell) {
                        const onAnimationEnd = () => {
                            cell.classList.remove('animate-complete');
                            cell.removeEventListener('animationend', onAnimationEnd);
                        };
                        cell.addEventListener('animationend', onAnimationEnd);

                        cell.classList.remove('animate-complete');
                        void cell.offsetWidth;
                        cell.classList.add('animate-complete');
                    }
                }, index * 50);
            });
        }

        function triggerWinAnimation() {
            soundManager.playSound('victory');
            const gridEl = document.getElementById('sudokuGrid');
            const animationDuration = 800;
            const staggerDelay = 50;

            gameState.selectedRow = null;
            gameState.selectedCol = null;
            renderGrid();

            for (let i = 0; i < 81; i++) {
                const row = Math.floor(i / 9);
                const col = i % 9;
                const cell = gridEl.children[i];
                if (cell) {
                    cell.style.animationDelay = `${(row + col) * staggerDelay}ms`;
                    cell.classList.add('win-animate');
                }
            }

            const totalAnimationTime = ((9 - 1) + (9 - 1)) * staggerDelay + animationDuration;
            setTimeout(() => {
                showGameOverModal(true);
            }, totalAnimationTime);
        }

        function renderGrid() {
            const grid = document.getElementById('sudokuGrid');
            grid.innerHTML = '';

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    
                    if ((col + 1) % 3 === 0 && col !== 8) cell.classList.add('thick-right');
                    if ((row + 1) % 3 === 0 && row !== 8) cell.classList.add('thick-bottom');
                    
                    if (gameState.selectedRow === row && gameState.selectedCol === col) {
                        cell.classList.add('selected');
                    }
                    
                    if (options.indicativeMode && gameState.errorGrid[row][col]) {
                        cell.classList.add('error');
                    }
                    
                    if (options.highlightMode) {
                        if (gameState.selectedRow !== null && gameState.selectedCol !== null) {
                            const selectedValue = gameState.currentGrid[gameState.selectedRow][gameState.selectedCol];
                            
                            if (row === gameState.selectedRow || col === gameState.selectedCol) {
                                cell.classList.add('highlight-area');
                            }
                            
                            const selectedBlockRow = Math.floor(gameState.selectedRow / 3);
                            const selectedBlockCol = Math.floor(gameState.selectedCol / 3);
                            const currentBlockRow = Math.floor(row / 3);
                            const currentBlockCol = Math.floor(col / 3);
                            
                            if (selectedBlockRow === currentBlockRow && selectedBlockCol === currentBlockCol) {
                                cell.classList.add('highlight-area');
                            }
                            
                            if (selectedValue !== 0 && gameState.currentGrid[row][col] === selectedValue) {
                                cell.classList.add('highlight-number');
                            }
                        }
                        else if (gameState.highlightedNumber !== null) {
                            if (gameState.currentGrid[row][col] === gameState.highlightedNumber) {
                                cell.classList.add('highlight-number');
                            }
                        }
                    }
                    
                    cell.onclick = () => selectCell(row, col);
                    
                    if (gameState.currentGrid[row][col] !== 0) {
                        const numberSpan = document.createElement('span');
                        numberSpan.textContent = gameState.currentGrid[row][col];
                        cell.appendChild(numberSpan);

                        cell.classList.add(gameState.originalGrid[row][col] !== 0 ? 'original' : 'user');

                        if (gameState.isInitialRender && gameState.originalGrid[row][col] !== 0) {
                            cell.classList.add('initial-fade-in');
                            cell.style.animationDelay = `${(row + col) * 0.04}s`;
                        }
                    } else if (gameState.notesGrid[row][col].size > 0) {
                        const notesContainer = document.createElement('div');
                        notesContainer.className = 'notes-container';
                        
                        for (let notePos = 1; notePos <= 9; notePos++) {
                            const noteEl = document.createElement('div');
                            noteEl.className = 'note';
                            
                            if (gameState.notesGrid[row][col].has(notePos)) {
                                noteEl.textContent = notePos;
                                
                                if (options.highlightMode) {
                                    if (gameState.selectedRow !== null && gameState.selectedCol !== null) {
                                        const selectedValue = gameState.currentGrid[gameState.selectedRow][gameState.selectedCol];
                                        if (selectedValue !== 0 && notePos === selectedValue) {
                                            noteEl.classList.add('highlighted');
                                        }
                                    }
                                    else if (gameState.highlightedNumber !== null && notePos === gameState.highlightedNumber) {
                                        noteEl.classList.add('highlighted');
                                    }
                                }
                            }
                            
                            notesContainer.appendChild(noteEl);
                        }
                        
                        cell.appendChild(notesContainer);
                    }
                    
                    grid.appendChild(cell);
                }
            }

            if (gameState.isInitialRender) {
                const gridEl = document.getElementById('sudokuGrid');
                gridEl.classList.add('no-events');
                setTimeout(() => {
                    gameState.isInitialRender = false;
                    gridEl.classList.remove('no-events');
                }, 1500);
            }
        }

        function selectCell(row, col) {
            if (gameState.isInitialRender) return;
            gameState.selectedRow = row;
            gameState.selectedCol = col;
            gameState.highlightedNumber = null;
            renderGame();
        }

        function renderNumberButtons() {
            const container = document.getElementById('numberButtons');
            container.innerHTML = '';
            
            const remaining = options.indicativeMode ? getRemainingNumbers() : {};
            
            let selectedCellNotes = new Set();
            if (gameState.selectedRow !== null && gameState.selectedCol !== null && gameState.notesMode) {
                selectedCellNotes = gameState.notesGrid[gameState.selectedRow][gameState.selectedCol];
            }
            
            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.className = 'number-button';
                
                if (options.indicativeMode && (remaining[i] || 0) === 0) {
                    btn.style.visibility = 'hidden';
                } else {
                    btn.style.visibility = 'visible';
                }
                
                const shouldHighlight = selectedCellNotes && selectedCellNotes.has && selectedCellNotes.has(i);
                
                btn.onclick = () => placeNumber(i);
                
                const numberText = document.createElement('div');
                numberText.textContent = i;
                btn.appendChild(numberText);
                
                if (options.indicativeMode) {
                    const countText = document.createElement('div');
                    countText.className = 'remaining-count';
                    countText.textContent = remaining[i] || 0;
                    btn.appendChild(countText);
                }
                
                if (shouldHighlight) {
                    btn.classList.add('highlighted');
                }
                
                container.appendChild(btn);
            }
        }

        function getRemainingNumbers() {
            const remaining = {};
            for (let i = 1; i <= 9; i++) remaining[i] = 9;
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const number = gameState.currentGrid[row][col];
                    if (number !== 0) {
                        remaining[number] = (remaining[number] || 0) - 1;
                    }
                }
            }
            
            return remaining;
        }

        function cleanObsoleteNotes() {
            if (!options.indicativeMode) return;
            
            const remaining = getRemainingNumbers();
            
            for (let number = 1; number <= 9; number++) {
                if (remaining[number] === 0) {
                    for (let row = 0; row < 9; row++) {
                        for (let col = 0; col < 9; col++) {
                            if (gameState.notesGrid[row][col].has(number)) {
                                gameState.notesGrid[row][col].delete(number);
                            }
                        }
                    }
                }
            }
        }

        function saveAction(action) {
            gameState.actionHistory.push(action);
            if (gameState.actionHistory.length > 50) {
                gameState.actionHistory.shift();
            }
            updateUndoButton();
        }

        function updateUndoButton() {
            const undoButton = document.getElementById('undoButton');
            undoButton.disabled = gameState.actionHistory.length === 0;
        }

        function isCorrectMove(row, col, number) {
            if (gameState.solvedGrid.length === 0) {
                return isValidMove(row, col, number);
            }
            return gameState.solvedGrid[row][col] === number;
        }

        function isValidMove(row, col, number) {
            for (let c = 0; c < 9; c++) {
                if (c !== col && gameState.currentGrid[row][c] === number) return false;
            }
            
            for (let r = 0; r < 9; r++) {
                if (r !== row && gameState.currentGrid[r][col] === number) return false;
            }
            
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                    if ((r !== row || c !== col) && gameState.currentGrid[r][c] === number) return false;
                }
            }
            
            return true;
        }

        function isSudokuComplete() {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (gameState.currentGrid[row][col] === 0) return false;
                    if (options.indicativeMode && gameState.solvedGrid.length > 0) {
                        if (gameState.currentGrid[row][col] !== gameState.solvedGrid[row][col]) return false;
                    } else {
                        if (!isValidMove(row, col, gameState.currentGrid[row][col])) return false;
                    }
                }
            }
            return true;
        }

        function updateErrors() {
            if (!options.indicativeMode) {
                 gameState.errorGrid = Array(9).fill().map(() => Array(9).fill(false));
                return;
            }
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (gameState.currentGrid[row][col] !== 0 && gameState.originalGrid[row][col] === 0) {
                        if (gameState.solvedGrid.length > 0) {
                            gameState.errorGrid[row][col] = gameState.currentGrid[row][col] !== gameState.solvedGrid[row][col];
                        } else {
                            gameState.errorGrid[row][col] = !isValidMove(row, col, gameState.currentGrid[row][col]);
                        }
                    } else {
                        gameState.errorGrid[row][col] = false;
                    }
                }
            }
        }

        function updateErrorDisplay() {
            const errorEl = document.getElementById('errorDisplay');
            if (options.indicativeMode) {
                errorEl.classList.remove('hidden');
                errorEl.textContent = `Errors: ${gameState.errorCount}/3`;
                errorEl.style.color = gameState.errorCount >= 2 ? '#f44336' : '#ffffff';
            } else {
                errorEl.classList.add('hidden');
            }
        }

        function resetGame() {
            gameState.currentGrid = gameState.originalGrid.map(row => [...row]);
            gameState.errorGrid = Array(9).fill().map(() => Array(9).fill(false));
            gameState.notesGrid = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
            gameState.selectedRow = null;
            gameState.selectedCol = null;
            gameState.errorCount = 0;
            gameState.gameWon = false;
            gameState.gameLost = false;
            gameState.notesMode = false;
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.actionHistory = [];
            gameState.isInitialRender = true;

            document.getElementById('notesButton').classList.remove('active');

            clearInterval(gameState.gameTimer);
            if (options.showTimer) {
                startTimer();
            }

            saveGameState();
            renderGame();
        }

        function showGameOverModal(won) {
            const modal = document.getElementById('gameOverModal');
            const title = document.getElementById('gameOverTitle');
            const content = document.getElementById('gameOverContent');
            const actions = document.getElementById('gameOverActions');

            clearInterval(gameState.gameTimer);

            title.textContent = won ? 'Congratulations!' : 'Game Over';
            
            if (won) {
                content.innerHTML = `
                    <p>You solved the sudoku!</p>
                    <div style="margin-top: 15px; padding: 12px; background: #1b5e20; border: 1px solid #4caf50; border-radius: 8px; display: flex; align-items: center; gap: 8px;">
                        <span>⏱️</span>
                        <strong>Time: ${formatTime(gameState.elapsedTime)}</strong>
                    </div>
                `;
            } else {
                content.innerHTML = '<p>You made too many errors (3 max).</p>';
            }

            actions.innerHTML = `
                <button class="btn btn-secondary" onclick="closeGameOverModal(); showScreen('menuScreen')">Main Menu</button>
                ${!won ? '<button class="btn btn-primary" onclick="closeGameOverModal(); resetGame()">Try Again</button>' : ''}
            `;

            modal.classList.add('show');
        }

        function showExportModal(jsonString, copied) {
            const modal = document.getElementById('exportModal');
            const textarea = document.getElementById('exportTextarea');
            
            textarea.value = jsonString;
            modal.classList.add('show');
            
            if (copied) {
                document.querySelector('#exportModal .modal-title').textContent = 'Export Current State - ✓ Copied!';
            } else {
                document.querySelector('#exportModal .modal-title').textContent = 'Export Current State';
            }
        }

        function encodeGrid(originalGrid, difficulty, difficultyLabel) {
            const gridData = {
                grid: originalGrid,
                difficulty: difficulty,
                label: difficultyLabel,
                timestamp: Date.now()
            };
            return btoa(JSON.stringify(gridData));
        }

        function decodeGrid(encodedString) {
            try {
                return JSON.parse(atob(encodedString));
            } catch (e) {
                console.error('Error decoding grid:', e);
                return null;
            }
        }

        function showShareModal(url, copied) {
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-title">Share This Grid</div>
                    <p>Share this link with friends to play the same Sudoku:</p>
                    <div style="background: #1e1e1e; padding: 10px; border-radius: 5px; margin: 15px 0; word-break: break-all; font-size: 12px; border: 1px solid #404040;">
                        ${url}
                    </div>
                    ${copied ? '<p style="color: #4caf50;">✓ Link copied to clipboard!</p>' : '<p style="color: #ff9800;">⚠ Please copy the link manually</p>'}
                    <div class="modal-actions">
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove()">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function loadFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.has('grid')) {
                const gridData = decodeGrid(params.get('grid'));
                if (gridData && gridData.grid) {
                    return gridData;
                }
            }
            return null;
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            document.body.addEventListener('click', () => soundManager.init(), { once: true });
            
            try {
                loadOptions();

                document.addEventListener('visibilitychange', handleVisibilityChange);
                
                const sharedGrid = loadFromURL();
                if (sharedGrid) {
                    initializeGame(sharedGrid.grid, [], sharedGrid.label, sharedGrid.difficulty);
                    showScreen('gameScreen');
                    
                    setTimeout(() => {
                        const modal = document.createElement('div');
                        modal.className = 'modal show';
                        modal.innerHTML = `
                            <div class="modal-content">
                                <div class="modal-title">🎯 Shared Grid Loaded!</div>
                                <p>You're playing a ${sharedGrid.label} grid shared by someone else.</p>
                                <p>Note: Smart Hint Mode may not work perfectly with shared grids.</p>
                                <p>Good luck and have fun! 🍀</p>
                                <div class="modal-actions">
                                    <button class="btn btn-primary" onclick="this.closest('.modal').remove()">Let's Play!</button>
                                </div>
                            </div>
                        `;
                        document.body.appendChild(modal);
                    }, 500);
                } else if (loadSavedGame()) {
                    showScreen('gameScreen');
                    
                    if (options.showTimer && !gameState.gameWon && !gameState.gameLost) {
                        startTimer();
                    }
                    
                    renderGame();
                    
                    setTimeout(() => {
                        const modal = document.createElement('div');
                        modal.className = 'modal show';
                        modal.innerHTML = `
                            <div class="modal-content">
                                <div class="modal-title">💾 Game Restored!</div>
                                <p>Your ${gameState.difficulty} game has been restored.</p>
                                <p>Continue where you left off!</p>
                                <div class="modal-actions">
                                    <button class="btn btn-secondary" onclick="this.closest('.modal').remove(); clearSavedGame(); showScreen('menuScreen');">Start New Game</button>
                                    <button class="btn btn-primary" onclick="this.closest('.modal').remove();">Continue</button>
                                </div>
                            </div>
                        `;
                        document.body.appendChild(modal);
                    }, 300);
                } else {
                    showScreen('menuScreen');
                }
                
                console.log('App initialized successfully');
            } catch (error) {
                console.error('Initialization error:', error);
                alert('Error initializing app: ' + error.message);
            }
        });
    </script>
</body>
</html>

