<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Sudoku</title>
    <meta name="theme-color" content="#2196F3">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="My Sudoku">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIk1vbiBTdWRva3UiLAogICJzaG9ydF9uYW1lIjogIlN1ZG9rdSIsCiAgImRlc2NyaXB0aW9uIjogIkpldSBkZSBTdWRva3UgcGVyc29ubmFsaXPDqSIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiI2ZmZmZmZiIsCiAgInRoZW1lX2NvbG9yIjogIiMyMTk2RjMiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI3YVdSMGFEMGlOVEV5SWlCb1pXbG5hSFE5SWpVeE1pSWdkbWxsZDBKdmVEMGlNQ0F3TERRES0F5TREE5SWlCb1pIUndYbTl0QUFBTE1pVnZjbWNOQTFNbGRGa3Y0c3hJWElnZUhONXh0VER5cFNkYTFjeWJOeTNMaTJ5VDZOdCFYTzNVeXhNTm1ySERpRHlZdXYyTklpeHpQSERCVVhZWUZOTkFCTUZKOVpGdHdDRWc1MkVOTEFGRVhmQXZoZ09SelRmZUYxWnBEeVdKUkp2dDBzIiwKICAgICAgInNpemVzIjogIjUxMng1MTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIgogICAgfQogIF0KfQ==">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #121212;
            color: #ffffff;
            user-select: none;
            overflow-x: hidden;
            touch-action: manipulation;
        }

        .app-container {
            max-width: 480px;
            margin: 0 auto;
            background: #1e1e1e;
            min-height: 100vh;
        }

        .app-bar {
            background: #2d2d2d;
            padding: 16px;
            border-bottom: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-title {
            font-size: 18px;
            font-weight: bold;
            color: #ffffff;
        }

        .app-subtitle {
            font-size: 12px;
            color: #b0b0b0;
        }

        .app-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .timer-display {
            background: #1a237e;
            border: 1px solid #3f51b5;
            border-radius: 6px;
            padding: 4px 8px;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 14px;
            font-weight: bold;
            color: #90caf9;
        }

        .error-display {
            font-weight: bold;
            font-size: 14px;
            color: #ffffff;
        }

        .menu-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 80vh;
            padding: 20px;
        }

        .main-title {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .subtitle {
            font-size: 18px;
            color: #b0b0b0;
            margin-bottom: 10px;
        }

        .warning-text {
            font-size: 12px;
            color: #4caf50;
            font-style: italic;
            margin-bottom: 30px;
        }

        .option-button, .difficulty-button {
            width: 200px;
            height: 60px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .option-button {
            background: #404040;
            color: #ffffff;
            height: 50px;
        }

        .option-button:hover {
            background: #505050;
        }

        .game-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: calc(100vh - 80px);
            gap: 12px;
        }

        .sudoku-grid {
            width: 360px;
            height: 360px;
            border: 3px solid #ffffff;
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
        }

        .sudoku-cell {
            border: 0.5px solid #666666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            background: #2d2d2d;
            color: #ffffff;
            overflow: hidden;
        }

        .sudoku-cell.thick-right { border-right: 2px solid #ffffff; }
        .sudoku-cell.thick-bottom { border-bottom: 2px solid #ffffff; }
        .sudoku-cell.selected { 
            background: #ff8f00 !important; 
            color: #ffffff;
        }
        .sudoku-cell.error { background: #d32f2f; }
        .sudoku-cell.highlight-number { background: #f57c00; }
        .sudoku-cell.highlight-area { background: #424242; }
        .sudoku-cell.original { color: #ffffff; }
        .sudoku-cell.user { color: #90caf9; }

        .notes-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 1px;
            padding: 2px;
        }

        .note {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #90caf9;
            font-weight: bold;
            background: none;
            border-radius: 0;
        }

        .note.highlighted {
            background: #f57c00;
            color: #ffffff;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .action-button {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .notes-button {
            background: #404040;
            color: #ffffff;
            border: 2px solid #606060;
            position: relative;
        }

        .notes-button.active {
            background: #7b1fa2;
            color: #ffffff;
            border: 2px solid #ce93d8;
            box-shadow: 0 0 12px rgba(123, 31, 162, 0.6), 0 0 24px rgba(123, 31, 162, 0.3);
            transform: scale(1.15);
        }

        .notes-button.active::after {
            content: '';
            position: absolute;
            top: -4px;
            right: -4px;
            width: 8px;
            height: 8px;
            background: #4caf50;
            border-radius: 50%;
            border: 1px solid #ffffff;
        }

        .undo-button {
            background: #404040;
            color: #ffffff;
            border: 2px solid #606060;
        }

        .undo-button:hover:not(:disabled) {
            background: #505050;
            border-color: #707070;
        }

        .undo-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .action-button:hover:not(:disabled) {
            opacity: 0.8;
        }

        .notes-toggle {
            display: none;
        }

        .number-buttons {
            display: flex;
            flex-wrap: nowrap;
            gap: 4px;
            justify-content: center;
            overflow-x: auto;
            width: 100%;
            max-width: 400px;
        }

        .number-button {
            min-width: 38px;
            width: 38px;
            height: 50px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            background: #404040;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .number-button.highlighted {
            background: #ff9800 !important;
            color: #ffffff !important;
            border: 3px solid #ffc107 !important;
            transform: scale(1.1) !important;
            box-shadow: 0 0 15px rgba(255, 152, 0, 0.8) !important;
            z-index: 10 !important;
        }

        .number-button:hover:not(.highlighted) {
            background: #505050;
        }

        .number-button.erase {
            background: #d32f2f;
            font-size: 18px;
        }

        .number-button.erase:hover {
            background: #f44336;
        }

        .number-button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .remaining-count {
            font-size: 10px;
            color: #b0b0b0;
            font-weight: bold;
            margin-top: 2px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
        }

        .modal.show { display: flex; }

        .modal-content {
            background: #2d2d2d;
            color: #ffffff;
            margin: auto;
            padding: 20px;
            border-radius: 10px;
            max-width: 400px;
            width: 90%;
            border: 1px solid #404040;
        }

        .modal-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffffff;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .btn-primary { 
            background: #2196f3; 
            color: white; 
        }
        
        .btn-primary:hover { 
            background: #1976d2; 
        }

        .btn-secondary { 
            background: #404040; 
            color: #ffffff; 
        }
        
        .btn-secondary:hover { 
            background: #505050; 
        }

        .option-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #404040;
        }

        .option-item:last-child { border-bottom: none; }

        .checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #666666;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: #2d2d2d;
            color: #4caf50;
            font-weight: bold;
        }

        .checkbox.checked {
            background: #4caf50;
            border-color: #4caf50;
            color: #ffffff;
        }

        .option-details {
            flex: 1;
            margin-left: 12px;
        }

        .option-title {
            font-weight: bold;
            margin-bottom: 4px;
            color: #ffffff;
        }

        .option-subtitle {
            font-size: 12px;
            color: #b0b0b0;
        }

        .hidden { display: none !important; }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #ffffff;
        }

        /* Responsive for small screens */
        @media (max-width: 400px) {
            .sudoku-grid {
                width: 320px;
                height: 320px;
            }
            
            .game-screen {
                padding: 10px;
                gap: 15px;
            }
            
            .number-button {
                min-width: 32px;
                width: 32px;
                height: 45px;
                font-size: 14px;
            }
            
            .number-buttons {
                gap: 2px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Main Menu -->
        <div id="menuScreen" class="screen">
            <div class="app-bar">
                <div>
                    <div class="app-title">My Sudoku</div>
                </div>
            </div>
            <div class="menu-screen">
                <div class="main-title">SUDOKU</div>
                <div class="subtitle">Choose your level</div>
                <div class="warning-text">Local generator - instant loading!</div>
                
                <button class="option-button" onclick="showOptionsModal()">
                    <span>⚙️</span>
                    <span>Options</span>
                </button>
                
                <button class="difficulty-button" style="background: #4caf50; color: white;" onclick="startGame(0.2, 'Very Easy')">Very Easy</button>
                <button class="difficulty-button" style="background: #8bc34a; color: white;" onclick="startGame(0.35, 'Easy')">Easy</button>
                <button class="difficulty-button" style="background: #ff9800; color: white;" onclick="startGame(0.5, 'Medium')">Medium</button>
                <button class="difficulty-button" style="background: #ff5722; color: white;" onclick="startGame(0.65, 'Hard')">Hard</button>
                <button class="difficulty-button" style="background: #f44336; color: white;" onclick="startGame(0.8, 'Expert')">Expert</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="screen hidden">
            <div class="app-bar">
                <div>
                    <div class="app-title" id="gameTitle">Sudoku</div>
                    <div class="app-subtitle" id="gameSource">Source: Local Generator</div>
                </div>
                <div class="app-actions">
                    <div id="timerDisplay" class="timer-display hidden">
                        <span>⏱️</span>
                        <span id="timerText">0s</span>
                    </div>
                    <div id="errorDisplay" class="error-display hidden"></div>
                    <button class="btn btn-secondary" onclick="resetGame()">🔄</button>
                </div>
            </div>
            
            <div class="game-screen">
                <div class="sudoku-grid" id="sudokuGrid"></div>
                
                <div class="controls">
                    <div class="action-buttons">
                        <button class="action-button undo-button" id="undoButton" onclick="undoLastAction()">↶</button>
                        <button class="action-button notes-button" id="notesButton" onclick="toggleNotesMode()">✏️</button>
                    </div>
                    
                    <div class="number-buttons" id="numberButtons"></div>
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div id="optionsModal" class="modal">
            <div class="modal-content">
                <div class="modal-title">Game Options</div>
                <div id="optionsContent"></div>
                <div class="modal-actions">
                    <button class="btn btn-primary" onclick="closeOptionsModal()">Close</button>
                </div>
            </div>
        </div>

        <div id="gameOverModal" class="modal">
            <div class="modal-content">
                <div class="modal-title" id="gameOverTitle"></div>
                <div id="gameOverContent"></div>
                <div class="modal-actions" id="gameOverActions"></div>
            </div>
        </div>

        <div id="loadingModal" class="modal">
            <div class="modal-content">
                <div class="loading">
                    <div style="margin-right: 10px;">⏳</div>
                    <div>Generating grid...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Sudoku Generator - Inspired by py-sudoku algorithm
        class SudokuGenerator {
            constructor() {
                this.SIZE = 9;
                this.BOX_SIZE = 3;
                this.EMPTY = 0;
            }

            // Generate a complete valid Sudoku grid
            generateCompleteGrid() {
                const grid = Array(this.SIZE).fill().map(() => Array(this.SIZE).fill(this.EMPTY));
                this.fillGrid(grid);
                return grid;
            }

            // Fill the grid using backtracking
            fillGrid(grid) {
                const numbers = this.shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
                return this.fillGridRecursive(grid, 0, 0, numbers);
            }

            fillGridRecursive(grid, row, col, numbers) {
                if (row === this.SIZE) {
                    return true; // Grid is complete
                }

                const nextRow = col === this.SIZE - 1 ? row + 1 : row;
                const nextCol = col === this.SIZE - 1 ? 0 : col + 1;

                if (grid[row][col] !== this.EMPTY) {
                    return this.fillGridRecursive(grid, nextRow, nextCol, numbers);
                }

                const shuffledNumbers = this.shuffleArray([...numbers]);
                for (const num of shuffledNumbers) {
                    if (this.isValid(grid, row, col, num)) {
                        grid[row][col] = num;
                        if (this.fillGridRecursive(grid, nextRow, nextCol, numbers)) {
                            return true;
                        }
                        grid[row][col] = this.EMPTY;
                    }
                }
                return false;
            }

            // Check if placing a number is valid
            isValid(grid, row, col, num) {
                // Check row
                for (let c = 0; c < this.SIZE; c++) {
                    if (grid[row][c] === num) return false;
                }

                // Check column
                for (let r = 0; r < this.SIZE; r++) {
                    if (grid[r][col] === num) return false;
                }

                // Check 3x3 box
                const boxRow = Math.floor(row / this.BOX_SIZE) * this.BOX_SIZE;
                const boxCol = Math.floor(col / this.BOX_SIZE) * this.BOX_SIZE;
                for (let r = boxRow; r < boxRow + this.BOX_SIZE; r++) {
                    for (let c = boxCol; c < boxCol + this.BOX_SIZE; c++) {
                        if (grid[r][c] === num) return false;
                    }
                }

                return true;
            }

            // Create a puzzle by removing numbers from a complete grid
            createPuzzle(completeGrid, difficulty) {
                const puzzle = completeGrid.map(row => [...row]);
                const totalCells = this.SIZE * this.SIZE;
                const cellsToRemove = Math.floor(totalCells * difficulty);
                
                // Create array of all cell positions
                const positions = [];
                for (let r = 0; r < this.SIZE; r++) {
                    for (let c = 0; c < this.SIZE; c++) {
                        positions.push([r, c]);
                    }
                }

                // Shuffle positions for random removal
                this.shuffleArray(positions);

                let removed = 0;
                for (const [row, col] of positions) {
                    if (removed >= cellsToRemove) break;

                    const backup = puzzle[row][col];
                    puzzle[row][col] = this.EMPTY;

                    // Check if puzzle still has unique solution (simplified for performance)
                    if (this.countSolutions(puzzle) === 1) {
                        removed++;
                    } else {
                        puzzle[row][col] = backup; // Restore if no unique solution
                    }
                }

                return puzzle;
            }

            // Count solutions (simplified version for performance)
            countSolutions(puzzle, maxCount = 2) {
                const testGrid = puzzle.map(row => [...row]);
                let count = 0;
                
                const solve = (grid) => {
                    if (count >= maxCount) return count;
                    
                    const emptyCell = this.findEmptyCell(grid);
                    if (!emptyCell) {
                        count++;
                        return count;
                    }

                    const [row, col] = emptyCell;
                    for (let num = 1; num <= 9; num++) {
                        if (this.isValid(grid, row, col, num)) {
                            grid[row][col] = num;
                            solve(grid);
                            grid[row][col] = this.EMPTY;
                            if (count >= maxCount) return count;
                        }
                    }
                    return count;
                };
                
                return solve(testGrid);
            }

            // Find first empty cell
            findEmptyCell(grid) {
                for (let r = 0; r < this.SIZE; r++) {
                    for (let c = 0; c < this.SIZE; c++) {
                        if (grid[r][c] === this.EMPTY) {
                            return [r, c];
                        }
                    }
                }
                return null;
            }

            // Shuffle array in place
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Main method to generate a puzzle
            generate(difficulty = 0.5) {
                const completeGrid = this.generateCompleteGrid();
                return this.createPuzzle(completeGrid, difficulty);
            }
        }

        // Initialize generator
        const sudokuGenerator = new SudokuGenerator();

        // Global application state
        let gameState = {
            currentGrid: [],
            originalGrid: [],
            errorGrid: [],
            notesGrid: [],
            selectedRow: null,
            selectedCol: null,
            errorCount: 0,
            gameWon: false,
            gameLost: false,
            notesMode: false,
            startTime: null,
            elapsedTime: 0,
            gameTimer: null,
            difficulty: '',
            source: '',
            actionHistory: []
        };

        let options = {
            indicativeMode: false,
            highlightMode: true,
            showTimer: true
        };

        // Load saved options
        function loadOptions() {
            const saved = localStorage.getItem('sudoku_options');
            if (saved) {
                try {
                    options = {...options, ...JSON.parse(saved)};
                } catch (e) {
                    console.log('Error loading options:', e);
                }
            }
        }

        function saveOptions() {
            localStorage.setItem('sudoku_options', JSON.stringify(options));
        }

        // Screen navigation
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(screenId).classList.remove('hidden');
        }

        // Generate Sudoku grid locally
        function generateSudokuGrid(difficulty) {
            return sudokuGenerator.generate(difficulty);
        }

        // Start a new game
        async function startGame(difficulty, label) {
            document.getElementById('loadingModal').classList.add('show');
            
            try {
                // Add a small delay to show loading
                await new Promise(resolve => setTimeout(resolve, 200));
                const grid = generateSudokuGrid(difficulty);
                initializeGame(grid, label, difficulty);
                showScreen('gameScreen');
            } catch (e) {
                alert('Error generating Sudoku grid. Please try again.');
                console.error('Sudoku generation error:', e);
            } finally {
                document.getElementById('loadingModal').classList.remove('show');
            }
        }

        function initializeGame(grid, difficultyLabel, difficulty) {
            gameState.originalGrid = grid.map(row => [...row]);
            gameState.currentGrid = grid.map(row => [...row]);
            gameState.errorGrid = Array(9).fill().map(() => Array(9).fill(false));
            gameState.notesGrid = Array(9).fill().map(() => Array(9).fill().map(() => new Set()));
            gameState.selectedRow = null;
            gameState.selectedCol = null;
            gameState.errorCount = 0;
            gameState.gameWon = false;
            gameState.gameLost = false;
            gameState.notesMode = false;
            gameState.startTime = Date.now();
            gameState.elapsedTime = 0;
            gameState.difficulty = difficultyLabel;
            gameState.source = 'Local Generator';
            gameState.actionHistory = [];

            document.getElementById('gameTitle').textContent = `Sudoku - ${difficultyLabel}`;
            document.getElementById('gameSource').textContent = `Source: Local Generator (${Math.round(difficulty * 100)}% difficulty)`;

            clearInterval(gameState.gameTimer);
            if (options.showTimer) {
                startTimer();
            }

            renderGame();
        }

        function saveAction(action) {
            gameState.actionHistory.push(action);
            // Limit history to 50 actions
            if (gameState.actionHistory.length > 50) {
                gameState.actionHistory.shift();
            }
            updateUndoButton();
        }

        function updateUndoButton() {
            const undoButton = document.getElementById('undoButton');
            undoButton.disabled = gameState.actionHistory.length === 0;
        }

        function undoLastAction() {
            if (gameState.actionHistory.length === 0) return;
            
            const lastAction = gameState.actionHistory.pop();
            
            if (lastAction.type === 'number') {
                gameState.currentGrid[lastAction.row][lastAction.col] = lastAction.oldValue;
                if (lastAction.oldNotes) {
                    gameState.notesGrid[lastAction.row][lastAction.col] = new Set(lastAction.oldNotes);
                } else {
                    gameState.notesGrid[lastAction.row][lastAction.col] = new Set();
                }
            } else if (lastAction.type === 'note') {
                if (lastAction.action === 'add') {
                    gameState.notesGrid[lastAction.row][lastAction.col].delete(lastAction.number);
                } else {
                    gameState.notesGrid[lastAction.row][lastAction.col].add(lastAction.number);
                }
            }
            
            if (options.indicativeMode) {
                updateErrors();
            }
            
            updateUndoButton();
            renderGame();
        }

        function
